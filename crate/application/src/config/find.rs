use std::env;
use std::ffi;
use std::path::{Path, PathBuf};

use config::error::Result;
use config::FindContext;

/// Finds and returns the path to the configuration file.
///
/// # Parameters:
///
/// * `file_name`: Name of the file to search for which should be next to the executable.
pub fn find(file_name: &str) -> Result<PathBuf> {
    find_in(Path::new(""), &file_name)
}

/// Finds and returns the path to the configuration file within the given configuration directory.
///
/// # Parameters:
///
/// * `conf_dir`: Directory relative to the executable in which to search for configuration.
/// * `file_name`: Name of the file to search for.
pub fn find_in<P: AsRef<Path> + AsRef<ffi::OsStr>>(
    conf_dir: P,
    file_name: &str,
) -> Result<PathBuf> {
    let mut exe_dir = env::current_exe()?;
    exe_dir.pop();

    let mut base_dirs = vec![exe_dir];

    if cfg!(debug_assertions) {
        base_dirs.append(&mut development_base_dirs());
    }

    for base_dir in &base_dirs {
        let mut conf_path = base_dir.join(&conf_dir);
        conf_path.push(&file_name);

        if conf_path.exists() {
            return Ok(conf_path);
        }
    }

    let find_context = FindContext {
        base_dirs,
        conf_dir: PathBuf::from(&conf_dir),
        file_name: file_name.to_owned(),
    }; // kcov-ignore
    Err(find_context.into())
}

fn development_base_dirs() -> Vec<PathBuf> {
    let mut base_dirs = Vec::new();

    // Not sure that we need to have both OUT_DIR and CARGO_MANIFEST_DIR looked up. When we add
    // other resources we probably want to just read OUT_DIR and not CARGO_MANIFEST_DIR
    let development_base_dirs = vec![option_env!("OUT_DIR"), option_env!("CARGO_MANIFEST_DIR")];
    for development_dir in &development_base_dirs {
        if let &Some(dir) = development_dir {
            base_dirs.push(Path::new(dir).to_owned());
        }
    }

    base_dirs
}

#[cfg(test)]
mod test {
    use std::env;
    use std::path::PathBuf;

    use tempdir::TempDir;
    use tempfile::{NamedTempFile, NamedTempFileOptions};

    use config::error::ErrorKind;
    use config::FindContext;
    use super::{development_base_dirs, find, find_in};

    fn exe_dir() -> PathBuf {
        let mut exe_dir = env::current_exe().unwrap();
        exe_dir.pop();
        exe_dir
    }

    fn setup(conf_dir: Option<&str>) -> Option<(Option<TempDir>, NamedTempFile)> {
        if let Some(conf_dir) = conf_dir {
            let conf_path = PathBuf::from(conf_dir);

            // normalize relative paths to be relative to exe directory instead of working directory
            let exe_dir = exe_dir();
            let conf_parent;
            let temp_dir;

            // if the conf_path is absolute, or is the exe directory, we don't create a temp_dir
            if conf_path.is_absolute() || conf_dir == "" {
                conf_parent = exe_dir;
                temp_dir = None;
            } else {
                let tmp_dir = TempDir::new_in(exe_dir, conf_dir).unwrap();

                conf_parent = tmp_dir.path().to_owned();
                temp_dir = Some(tmp_dir);
            } // kcov-ignore

            return Some((
                temp_dir,
                NamedTempFileOptions::new()
                                    .prefix("config")
                                    .suffix(".ron")
                                    // don't include randomly generated bytes in the file name
                                    .rand_bytes(0)
                                    .create_in(conf_parent)
                                    .unwrap(),
            )); // kcov-ignore
        }

        None
    }

    #[test]
    fn find_in_returns_conf_path_when_conf_file_exists() {
        let (temp_dir, _conf_path) = setup(Some("resources")).unwrap();
        let temp_dir = temp_dir.unwrap();

        let expected = temp_dir.path().join("config.ron");
        assert_eq!(expected, find_in(&temp_dir.path(), "config.ron").unwrap());
    }

    #[test]
    fn find_returns_conf_path_when_conf_file_exists() {
        let (_, _conf_path) = setup(Some("")).unwrap();

        assert_eq!(exe_dir().join("config.ron"), find("config.ron").unwrap());
    }

    #[test]
    fn find_returns_error_when_conf_file_does_not_exist() {
        let _ = setup(None);

        if let &ErrorKind::Find(ref find_context) = find("config.ron").unwrap_err().kind() {
            let mut base_dirs = vec![exe_dir()];
            base_dirs.append(&mut development_base_dirs());
            let expected = FindContext {
                base_dirs,
                conf_dir: PathBuf::from(""),
                file_name: "config.ron".to_owned(),
            }; // kcov-ignore

            assert_eq!(&expected, find_context);
        } else {
            panic!("Expected `find` to return error"); // kcov-ignore
        }
    }
}
